#!/usr/bin/env python

import sys
import getopt
import imghdr
import optparse
from PIL import Image, ImageChops
import numpy as np
from numpy.linalg import norm
from scipy import signal
from scipy import ndimage
import cmath

def matchTemplate(patternArg, sourceArg):
    """
    Attempts to find the pattern image in the source image.

    Arguments:
    patternArg -- The path to the pattern image (small image) (template)
    sourceArg -- The path to the source image (big image) (image)

    Returns -1 if an error occurs, otherwise returns 0.
    
    """

    # Convert Source Image into a numpy array grayscaled
    sourceName = sourceArg.rpartition('/')[2]
    sourceArray = Image.open(sourceArg).convert('L')
    numpySource = np.asarray(sourceArray)
    numpySource.flags.writeable = True
    numpySource = np.ascontiguousarray(numpySource, dtype=np.float32)

    # Convert Pattern Image into a numpy array grayscaled
    patternName = patternArg.rpartition('/')[2]
    patternArray = Image.open(patternArg).convert('L')
    numpyPattern = np.asarray(patternArray)
    numpyPattern.flags.writeable = True
    numpyPattern = np.ascontiguousarray(numpyPattern, dtype=np.float32)

    sourceWidth, sourceHeight = sourceArray.size
    patternWidth, patternHeight = patternArray.size


    # FFT Stuff + Normalization of the Numpy Array
    template_mean = np.mean(numpyPattern)
    numpyPattern -= template_mean

    corr = np.ascontiguousarray(signal.fftconvolve(numpySource,
                                                   numpyPattern[::-1, ::-1],
                                                   mode="valid"),
                                dtype=np.float32)

    #normalize(corr)

    # Find the max value and print it
    ij = np.unravel_index(corr.argmax(), corr.shape)
    m_xs, m_ys = ij[::-1]
    print "%s matches %s at %ix%i+%i+%i" % (patternName, sourceName, patternWidth, patternHeight, m_xs, m_ys)   
    
    #Function Completed
    return 0


def normalize(array, imin = -1, imax = 1):
    """
    I = Imin + (Imax-Imin)*(D-Dmin)/(Dmax-Dmin)
    """

    dmin = array.min()
    dmax = array.max()


    array -= dmin;
    array *= (imax - imin)
    array /= (dmax-dmin)
    array += imin

    return array

def printError(error, testerFlag):
    """
    Prints errors after appending 'Error: ' to the front of them.

    Arguments:
    error -- The error string to be printed
    testerFlag -- True if SPIMS is being run by the tester

    Errors are normally printed to standard error, but if SPIMS is 
    being run by the tester they are printed to standard out.

    """

    if testerFlag:
        print 'Error: ' + error
    else:
        print >> sys.stderr, 'Error: ' + error

def isInputValid(patternArg, sourceArg, testerFlag):
    """
    Determines whether or not the provided arguments are valid.

    Arguments:
    patternArg -- The path to the pattern Image
    sourceArg -- The path to the source Image
    testerFlag -- True if SPIMS is being run by the tester

    Returns True if the arguments are valid, otherwise returns False.

    """
    
    # Make sure both args were specified
    if not patternArg or not sourceArg:
        printError('Invalid Arguments. Must provide a pattern(-p) and source(-s) image!', testerFlag)
        return False

    # Make sure images exist and are of the correct type
    try:
        validTypes = ['gif', 'jpeg', 'png']
        sourceType = imghdr.what(sourceArg)
        patternType = imghdr.what(patternArg)

        if sourceType not in validTypes or patternType not in validTypes:
            printError('Provided images must be GIF, JPEG, or PNG!', testerFlag)
            return False

    except IOError as e:
        printError('Image files cannot be found!', testerFlag)
        return False

    # Arguments are valid
    return True

def main(argv):
    parser = optparse.OptionParser(description='Software Dev Image Matching Software')
    parser.add_option('-p', '--pattern', dest='pattern', help='The pattern or template image to be found')
    parser.add_option('-s', '--source', dest='source', help='The source image to search in')
    parser.add_option('-t', '--tester', dest='tester', help=optparse.SUPPRESS_HELP, action="store_true")
    (options, args) = parser.parse_args()

    if isInputValid(options.pattern, options.source, options.tester):
        return matchTemplate(options.pattern, options.source)   
   
    # Arguments were invalid 
    return -1

if __name__ == "__main__":
    main(sys.argv[1:])
