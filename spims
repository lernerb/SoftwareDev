#!/usr/bin/env python

import sys
import getopt
import imghdr
import cmath
import numpy as np
from PIL import Image, ImageChops
from numpy.linalg import norm
from scipy import signal
from scipy import ndimage
from os import listdir
from os.path import isdir, join


def matchTemplate(patternArg, sourceArg):
    """
    Attempts to find the pattern image in the source image.

    Arguments:
    patternArg -- The path to the pattern image (small image) (template)
    sourceArg -- The path to the source image (big image) (image)

    Returns True if completed successfully, otherwise returns False.
    
    """

    # Convert Source Image into a numpy array grayscaled
    sourceName = sourceArg.rpartition('/')[2]
    sourceArray = Image.open(sourceArg).convert('L')
    numpySource = np.asarray(sourceArray)
    numpySource.flags.writeable = True
    numpySource = np.ascontiguousarray(numpySource, dtype=np.float32)

    # Convert Pattern Image into a numpy array grayscaled
    patternName = patternArg.rpartition('/')[2]
    patternArray = Image.open(patternArg).convert('L')
    numpyPattern = np.asarray(patternArray)
    numpyPattern.flags.writeable = True
    numpyPattern = np.ascontiguousarray(numpyPattern, dtype=np.float32)

    sourceWidth, sourceHeight = sourceArray.size
    patternWidth, patternHeight = patternArray.size


    # FFT Stuff + Normalization of the Numpy Array
    template_mean = np.mean(numpyPattern)
    numpyPattern -= template_mean

    corr = np.ascontiguousarray(signal.fftconvolve(numpySource,
                                                   numpyPattern[::-1, ::-1],
                                                   mode="valid"),
                                dtype=np.float32)

    #normalize(corr)

    # Find the max value and print it
    ij = np.unravel_index(corr.argmax(), corr.shape)
    m_xs, m_ys = ij[::-1]
    print "%s matches %s at %ix%i+%i+%i" % (patternName, sourceName, patternWidth, patternHeight, m_xs, m_ys)   
    
    #Exit Successfully
    return True


def normalize(array, imin = -1, imax = 1):
    """
    I = Imin + (Imax-Imin)*(D-Dmin)/(Dmax-Dmin)
    """

    dmin = array.min()
    dmax = array.max()


    array -= dmin;
    array *= (imax - imin)
    array /= (dmax-dmin)
    array += imin

    return array

def printError(error, testerFlag):
    """
    Prints errors after appending 'Error: ' to the front of them.

    Arguments:
    error -- The error string to be printed
    testerFlag -- True if SPIMS is being run by the tester

    Errors are normally printed to standard error, but if SPIMS is 
    being run by the tester they are printed to standard out.

    """

    if testerFlag:
        print 'Error: ' + error
    else:
        print >> sys.stderr, 'Error: ' + error

def isValidType(filePath, testerFlag):
    """
    Determines whether or not the provided path is a valid image.

    Arguments:
    filePath -- The path to the file we are checking
    testerFlag -- True if SPIMS is being run by the tester

    Returns True if the file is a valid image, otherwise returns False.

    """

    # Make sure images exist and are of the correct type
    try:
        if isdir(filePath):
            printError('Provided directory contains subdirectories!', testerFlag)
            return False

        validTypes = ['gif', 'jpeg', 'png']
        fileType = imghdr.what(filePath)

        if fileType not in validTypes:
            printError('Provided images must be GIF, JPEG, or PNG!', testerFlag)
            return False

    except IOError as e:
        printError('Image file cannot be found!', testerFlag)
        return False

    # Image is valid
    return True

def isAllValid(patterns, sources, testerFlag):
    """
    Determines whether or not the provided arguments are valid.

    Arguments:
    patterns -- The list of pattern paths
    sources -- The list of source paths
    testerFlag -- True if SPIMS is being run by the tester

    Returns True if all the arguments are valid, otherwise returns False.

    """

    # Make sure all patterns are valid
    for pattern in patterns:
        if not isValidType(pattern, testerFlag):
            return False

    # Make sure all sources are valid
    for source in sources:
        if not isValidType(source, testerFlag):
            return False

    # All are valid
    return True

def validateArgs(patternArg, patternDirArg, sourceArg, sourceDirArg, testerFlag):
    """
    Validates the arguments.

    Arguments:
    patternArg -- The path to the pattern image
    patternDirArg -- The path to the directory of pattern images
    sourceArg -- The path to the source image
    sourceDirArg -- The path to the directory of source images
    testerFlag -- True if SPIMS is being run by the tester

    Returns False if any arguments are invalid, otherwise 
    returns a tuple containing a list of patterns and a list of sources

    """

    # I originally had combined many these if statements, but decided to split them up
    # so that it will give a more specific error message, and be easier to read.

    # Make sure a pattern image is given
    if not patternArg and not patternDirArg:
        printError('Invalid Arguments. No pattern images provided!', testerFlag)
        return False
 
    # Make sure a source image is given
    if not sourceArg and not sourceDirArg:
        printError('Invalid Arguments. No source images provided!', testerFlag)
        return False

    # Make sure only one pattern arg is given
    if patternArg and patternDirArg:
        printError('Invalid Arguments. Must only provide one pattern argument!', testerFlag)
        return False

    # Make sure only one source arg is given
    if sourceArg and sourceDirArg:
        printError('Invalid Arguments. Must only provide one source argument!', testerFlag)
        return False

    # Creating lists of all patterns and sources
    patterns = []
    sources = []

    # Add the existing arguments to the lists
    if patternArg:
        patterns.append(patternArg)
    
    if sourceArg:
        sources.append(sourceArg)

    if patternDirArg:
        for patternName in listdir(patternDirArg):
            patterns.append(join(patternDirArg, patternName))

    if sourceDirArg:
        for sourceName in listdir(sourceDirArg):
            sources.append(join(sourceDirArg, sourceName))

    # Make sure all paths are valid files
    if isAllValid(patterns, sources, testerFlag):
        return patterns, sources

    return False

def main(argv):
    patternArg = None
    patternDirArg = None
    sourceArg = None
    sourceDirArg = None
    testerFlag = '-t' in argv
    
    if '-p' in argv:
        i = argv.index('-p') + 1
        if len(argv) > i:
            patternArg = argv[i]

    if '-pdir' in argv:
        i = argv.index('-pdir') + 1
        if len(argv) > i:
            patternDirArg = argv[i]

    if '-s' in argv:
        i = argv.index('-s') + 1
        if len(argv) > i:
            sourceArg = argv[i]

    if '-sdir' in argv:
        i = argv.index('-sdir') + 1
        if len(argv) > i:
            sourceDirArg = argv[i]

    paths = validateArgs(patternArg, patternDirArg, sourceArg, sourceDirArg, testerFlag)

    if paths:
        # If path is not false, then it is a tuple of the patterns and sources
        patterns, sources = paths

        # Try to find matches between all combinations of patterns and sources
        for pattern in patterns:
            for source in sources:
                if not matchTemplate(pattern, source):
                    # Error occured while finding a match. Stop and exit.
                    return -1   
   
    # Program completed successfully 
    return 1

if __name__ == "__main__":
    main(sys.argv[1:])
