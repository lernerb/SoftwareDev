#!/usr/bin/env python

import sys
import getopt
import imghdr
import optparse
from PIL import Image, ImageChops
import numpy as np
from numpy.linalg import norm
from scipy import signal
from scipy import ndimage
import cmath

def matchTemplate(patternArg, sourceArg):
    """
    Attempts to find the pattern image in the source image.

    Arguments:
    patternArg -- The path to the pattern image (small image) (template)
    sourceArg -- The path to the source image (big image) (image)

    Returns -1 if an error occurs, otherwise returns 0.
    
    """

    # Convert Source Image into a numpy array grayscaled
    sourceName = sourceArg.rpartition('/')[2]
    sourceArray = Image.open(sourceArg).convert('L')
    numpySource = np.asarray(sourceArray)
    numpySource.flags.writeable = True
    numpySource = np.ascontiguousarray(numpySource, dtype=np.float32)

    # Convert Pattern Image into a numpy array grayscaled
    patternName = patternArg.rpartition('/')[2]
    patternArray = Image.open(patternArg).convert('L')
    numpyPattern = np.asarray(patternArray)
    numpyPattern.flags.writeable = True
    numpyPattern = np.ascontiguousarray(numpyPattern, dtype=np.float32)

    sourceWidth, sourceHeight = sourceArray.size
    patternWidth, patternHeight = patternArray.size


    #And back to work



    template_mean = np.mean(numpyPattern)
    #template_rows = numpyPattern.shape[0]
    #template_cols = numpyPattern.shape[1]
    #image_sat = integral_image(numpySource)
    #image_sqr_sat = integral_image(numpySource**2)

    numpyPattern -= template_mean
    #template_ssd = np.sum(numpyPattern**2)
    # use inversed area for accuracy
    #inv_area = 1.0 / (numpyPattern.shape[0] * numpyPattern.shape[1])

    # when `dtype=float` is used, ascontiguousarray returns ``double``.
    corr = np.ascontiguousarray(signal.fftconvolve(numpySource,
                                                   numpyPattern[::-1, ::-1],
                                                   mode="valid"),
                                dtype=np.float32)


    ij = np.unravel_index(corr.argmax(), corr.shape)
    m_xs, m_ys = ij[::-1]

    #print np.unravel_index(corr.argmax(),corr.shape)

    #When we have our cod working we can uncomment this and add a confidence to get matches
    #match_indices = np.arange(result.size)[(result>confidence).flatten()]
    #print np.unravel_index(match_indices,result.shape)
    print "%s matches %s at %ix%i+%i+%i" % (patternName, sourceName, patternWidth, patternHeight, m_xs, m_ys)   

    """
    # move window through convolution results, normalizing in the process
    for r in range(corr.shape[0]):
        for c in range(corr.shape[1]):
            # subtract 1 because `i_end` and `c_end` are used for indexing into
            # summed-area table, instead of slicing windows of the image.
            r_end = r + template_rows - 1
            c_end = c + template_cols - 1

            window_sum = integrate(image_sat, r, c, r_end, c_end)
            window_mean_sqr = window_sum * window_sum * inv_area
            window_sqr_sum = integrate(image_sqr_sat, r, c, r_end, c_end)
            if window_sqr_sum <= window_mean_sqr:
                corr[r, c] = 0
                continue

            den = cmath.sqrt((window_sqr_sum - window_mean_sqr) * template_ssd)
            corr[r, c] /= den
     """
    
    # Function completed sucessfully    
    return 0


def integral_image(x):
    """Integral image / summed area table.

    Parameters
    ----------
    x : ndarray
        Input image.

    Returns
    -------
    S : ndarray
        Integral image / summed area table.

    """
    return x.cumsum(1).cumsum(0)


def integrate(sat, r0, c0,r1, c1):
    """
    Using a summed area table / integral image, calculate the sum
    over a given window.

    Parameters
    ----------
    sat : ndarray of float
        Summed area table / integral image.
    r0, c0 : int
        Top-left corner of block to be summed.
    r1, c1 : int
        Bottom-right corner of block to be summed.

    Returns
    -------
    S : int
        Sum over the given window.
    """

    S = 0

    S += sat[r1, c1]

    if (r0 - 1 >= 0) and (c0 - 1 >= 0):
        S += sat[r0 - 1, c0 - 1]

    if (r0 - 1 >= 0):
        S -= sat[r0 - 1, c1]

    if (c0 - 1 >= 0):
        S -= sat[r1, c0 - 1]
    return S

def printError(error, testerFlag):
    """
    Prints errors after appending 'Error: ' to the front of them.

    Arguments:
    error -- The error string to be printed
    testerFlag -- True if SPIMS is being run by the tester

    Errors are normally printed to standard error, but if SPIMS is 
    being run by the tester they are printed to standard out.

    """

    if testerFlag:
        print 'Error: ' + error
    else:
        print >> sys.stderr, 'Error: ' + error

def isInputValid(patternArg, sourceArg, testerFlag):
    """
    Determines whether or not the provided arguments are valid.

    Arguments:
    patternArg -- The path to the pattern Image
    sourceArg -- The path to the source Image
    testerFlag -- True if SPIMS is being run by the tester

    Returns True if the arguments are valid, otherwise returns False.

    """
    
    # Make sure both args were specified
    if not patternArg or not sourceArg:
        printError('Invalid Arguments. Must provide a pattern(-p) and source(-s) image!', testerFlag)
        return False

    # Make sure images exist and are of the correct type
    try:
        validTypes = ['gif', 'jpeg', 'png']
        sourceType = imghdr.what(sourceArg)
        patternType = imghdr.what(patternArg)

        if sourceType not in validTypes or patternType not in validTypes:
            printError('Provided images must be GIF, JPEG, or PNG!', testerFlag)
            return False

    except IOError as e:
        printError('Image files cannot be found!', testerFlag)
        return False

    # Arguments are valid
    return True

def main(argv):
    parser = optparse.OptionParser(description='Software Dev Image Matching Software')
    parser.add_option('-p', '--pattern', dest='pattern', help='The pattern or template image to be found')
    parser.add_option('-s', '--source', dest='source', help='The source image to search in')
    parser.add_option('-t', '--tester', dest='tester', help=optparse.SUPPRESS_HELP, action="store_true")
    (options, args) = parser.parse_args()

    if isInputValid(options.pattern, options.source, options.tester):
        return matchTemplate(options.pattern, options.source)   
   
    # Arguments were invalid 
    return -1

if __name__ == "__main__":
    main(sys.argv[1:])
