#!/usr/bin/env python

import sys
import imghdr
import cmath
import numpy as np
from numpy.linalg import norm
from scipy import signal, ndimage
from PIL import Image, ImageChops
from os import listdir
from os.path import isdir, join

def matchTemplate(patternArg, sourceArg):
    """
    Attempts to find the pattern image in the source image.

    Arguments:
    patternArg -- The path to the pattern image
    sourceArg -- The path to the source image 

    Returns True if completed successfully, otherwise returns False.
    """

    # Convert Source Image into a numpy array grayscaled
    sourceName = sourceArg.rpartition('/')[2]
    sourceArray = Image.open(sourceArg).convert('L')
    numpySource = np.asarray(sourceArray)
    numpySource.flags.writeable = True
    numpySource = np.ascontiguousarray(numpySource, dtype=np.float32)

    # Convert Pattern Image into a numpy array grayscaled
    patternName = patternArg.rpartition('/')[2]
    patternArray = Image.open(patternArg).convert('L')
    numpyPattern = np.asarray(patternArray)
    numpyPattern.flags.writeable = True
    numpyPattern = np.ascontiguousarray(numpyPattern, dtype=np.float32)

    # Get the original sizes of both images for normalization
    sourceWidth, sourceHeight = sourceArray.size
    patternWidth, patternHeight = patternArray.size

    if (patternWidth <= 10 and patternHeight <= 10 and sourceWidth <= 10 and sourceHeight <= 10):
        return matchSmallTemplate(patternArg, sourceArg)
        
    # FFT using a Normalized Cross Correlation
    template_mean = np.mean(numpyPattern)
    numpyPattern -= template_mean
    corr = np.ascontiguousarray(signal.fftconvolve(numpySource, numpyPattern[::-1, ::-1], mode="valid"), 
                                dtype=np.float32)
    
    corr = normalize(corr)

    # Find the max value and print it
    ij = np.unravel_index(corr.argmax(), corr.shape)
    m_xs, m_ys = ij[::-1]

    isConfirmedMatch = not isFalsePositive(m_xs, m_ys, sourceArg, patternArg)

    if isConfirmedMatch:
        print "%s matches %s at %ix%i+%i+%i" % (patternName, sourceName, patternWidth, patternHeight, m_xs, m_ys)   
    
    return True

def isFalsePositive(xs, ys, sourceArg, patternArg):

    sourceName = sourceArg.rpartition('/')[2]
    sourceImage = Image.open(sourceArg)
    patternName = patternArg.rpartition('/')[2]
    patternImage = Image.open(patternArg)

    sourceImage = sourceImage.convert(mode="L")
    sourceWidth, sourceHeight = sourceImage.size
    patternImage = patternImage.convert(mode="L")
    patternWidth, patternHeight = patternImage.size
    patternMask = Image.new(mode="L", size=patternImage.size, color=1)

    score = patternWidth*patternHeight
    sourceCrop = sourceImage.crop((xs,ys,xs+patternWidth,ys+patternHeight))
    diff = ImageChops.difference(patternImage, sourceCrop)
    notequal = ImageChops.darker(diff,patternMask)
    countnotequal = sum(notequal.getdata())
    score -= countnotequal
    
    return score < (patternWidth * patternHeight * .03)    
        
def matchSmallTemplate(patternArg, sourceArg):
    """
    Attempts to find the pattern image in the source image.

    Arguments:
    patternArg -- The path to the pattern image
    sourceArg -- The path to the source image

    Returns -1 if an error occurs, otherwise returns 0.
    
    """

    sourceName = sourceArg.rpartition('/')[2]
    sourceImage = Image.open(sourceArg)
    patternName = patternArg.rpartition('/')[2]
    patternImage = Image.open(patternArg)

    minScore = 0
    matching_xs = 0
    matching_ys = 0

    sourceImage = sourceImage.convert(mode="L")
    sourceWidth, sourceHeight = sourceImage.size
    patternImage = patternImage.convert(mode="L")
    patternWidth, patternHeight = patternImage.size
    patternMask = Image.new(mode="L", size=patternImage.size, color=1)
    
    for xs in range(sourceWidth-patternWidth+1):
        for ys in range(sourceHeight-patternHeight+1):
            score = patternWidth*patternHeight
            sourceCrop = sourceImage.crop((xs,ys,xs+patternWidth,ys+patternHeight))
            diff = ImageChops.difference(patternImage, sourceCrop)
            notequal = ImageChops.darker(diff,patternMask)
            countnotequal = sum(notequal.getdata())
            score -= countnotequal

            minScore = score
            matching_xs = xs
            matching_ys = ys

            if minScore > (patternWidth * patternHeight * .03):    
                print "%s matches %s at %ix%i+%i+%i" % (patternName, sourceName, patternWidth, patternHeight, matching_xs, matching_ys)
    
    # Function completed sucessfully    
    return True



def normalize(array, imin = -1, imax = 1):
    """
    I = Imin + (Imax-Imin)*(D-Dmin)/(Dmax-Dmin)

    """

    dmin = array.min()
    dmax = array.max()
    array -= dmin;
    array *= (imax - imin)
    array /= (dmax-dmin)
    array += imin

    return array

def printError(error, testerFlag):
    """
    Prints errors after appending 'Error: ' to the front of them.

    Arguments:
    error -- The error string to be printed
    testerFlag -- True if SPIMS is being run by the tester

    Errors are normally printed to standard error, but if SPIMS is 
    being run by the tester they are printed to standard out.

    """

    if testerFlag:
        print 'Error: ' + error
    else:
        print >> sys.stderr, 'Error: ' + error

def isValidType(filePath, testerFlag):
    """
    Determines whether or not the provided path is a valid image.

    Arguments:
    filePath -- The path to the file we are checking
    testerFlag -- True if SPIMS is being run by the tester

    Returns True if the file is a valid image, otherwise returns False.

    """

    # Make sure images exist and are of the correct type
    try:
        if isdir(filePath):
            printError('Received directory while expecting file!', testerFlag)
            return False

        validTypes = ['gif', 'jpeg', 'png']
        fileType = imghdr.what(filePath)

        if fileType not in validTypes:
            printError('Provided images must be GIF, JPEG, or PNG!', testerFlag)
            return False

    except IOError as e:
        printError('Image file cannot be found!', testerFlag)
        return False

    # Image is valid
    return True

def allValidTypes(patterns, sources, testerFlag):
    """
    Determines whether or not the provided files are valid types.

    Arguments:
    patterns -- The list of pattern paths
    sources -- The list of source paths
    testerFlag -- True if SPIMS is being run by the tester

    Returns True if all the files are valid, otherwise returns False.

    """

    # Make sure all patterns are valid
    for pattern in patterns:
        if not isValidType(pattern, testerFlag):
            return False

    # Make sure all sources are valid
    for source in sources:
        if not isValidType(source, testerFlag):
            return False

    # All are valid
    return True

def validateArgs(patternArg, patternDirArg, sourceArg, sourceDirArg, testerFlag):
    """
    Validates the arguments.

    Arguments:
    patternArg -- The path to the pattern image
    patternDirArg -- The path to the directory of pattern images
    sourceArg -- The path to the source image
    sourceDirArg -- The path to the directory of source images
    testerFlag -- True if SPIMS is being run by the tester

    Returns False if any arguments are invalid, otherwise 
    returns a tuple containing a list of patterns and a list of sources

    """

    # Make sure a pattern image is given
    if not patternArg and not patternDirArg:
        printError('Invalid Arguments. No pattern images provided!', testerFlag)
        return False
 
    # Make sure a source image is given
    if not sourceArg and not sourceDirArg:
        printError('Invalid Arguments. No source images provided!', testerFlag)
        return False

    # Make sure only one pattern arg is given
    if patternArg and patternDirArg:
        printError('Invalid Arguments. Must only provide one pattern argument!', testerFlag)
        return False

    # Make sure only one source arg is given
    if sourceArg and sourceDirArg:
        printError('Invalid Arguments. Must only provide one source argument!', testerFlag)
        return False

    # Creating lists of all patterns and sources
    patterns = []
    sources = []

    # Add the existing arguments to the lists
    if patternArg:
        patterns.append(patternArg)
    
    if sourceArg:
        sources.append(sourceArg)

    if patternDirArg:
        if not isdir(patternDirArg):
            printError('Given pattern directory is invalid!', testerFlag)
            return False

        for patternName in listdir(patternDirArg):
            patterns.append(join(patternDirArg, patternName))

    if sourceDirArg:
        if not isdir(sourceDirArg):
            printError('Given source directory is invalid!', testerFlag)
            return False

        for sourceName in listdir(sourceDirArg):
            sources.append(join(sourceDirArg, sourceName))

    # Make sure all paths are valid files
    if allValidTypes(patterns, sources, testerFlag):
        return patterns, sources

    return False

def main(argv):
    patternArg = None
    patternDirArg = None
    sourceArg = None
    sourceDirArg = None
    testerFlag = '-t' in argv
    
    if '-p' in argv:
        i = argv.index('-p') + 1
        if len(argv) > i:
            patternArg = argv[i]

    if '-pdir' in argv:
        i = argv.index('-pdir') + 1
        if len(argv) > i:
            patternDirArg = argv[i]

    if '-s' in argv:
        i = argv.index('-s') + 1
        if len(argv) > i:
            sourceArg = argv[i]

    if '-sdir' in argv:
        i = argv.index('-sdir') + 1
        if len(argv) > i:
            sourceDirArg = argv[i]

    # Validate the arguments and attempt to retrieve the pattern/source paths
    paths = validateArgs(patternArg, patternDirArg, sourceArg, sourceDirArg, testerFlag)

    if paths:
        # If path is not false, then it is a tuple of the patterns and sources
        patterns, sources = paths

        # Try to find matches between all combinations of patterns and sources
        for pattern in patterns:
            for source in sources:
                if not matchTemplate(pattern, source):
                    # Error occured while finding a match. Stop and exit.
                    return -1  
    else:
        # Arguments are invalid
        return -1 
   
    # Program completed successfully 
    return 1

if __name__ == "__main__":
    main(sys.argv[1:])

import sys
import imghdr
import cmath
import numpy as np
from numpy.linalg import norm
from scipy import signal, ndimage
from PIL import Image, ImageChops
from os import listdir
from os.path import isdir, join

def matchTemplate(patternArg, sourceArg):
    """
    Attempts to find the pattern image in the source image.

    Arguments:
    patternArg -- The path to the pattern image
    sourceArg -- The path to the source image 

    Returns True if completed successfully, otherwise returns False.
    """

    # Convert Source Image into a numpy array grayscaled
    sourceName = sourceArg.rpartition('/')[2]
    sourceArray = Image.open(sourceArg).convert('L')
    numpySource = np.asarray(sourceArray)
    numpySource.flags.writeable = True
    numpySource = np.ascontiguousarray(numpySource, dtype=np.float32)

    # Convert Pattern Image into a numpy array grayscaled
    patternName = patternArg.rpartition('/')[2]
    patternArray = Image.open(patternArg).convert('L')
    numpyPattern = np.asarray(patternArray)
    numpyPattern.flags.writeable = True
    numpyPattern = np.ascontiguousarray(numpyPattern, dtype=np.float32)

    # Get the original sizes of both images for normalization
    sourceWidth, sourceHeight = sourceArray.size
    patternWidth, patternHeight = patternArray.size

    # FFT using a Normalized Cross Correlation
    template_mean = np.mean(numpyPattern)
    numpyPattern -= template_mean
    corr = np.ascontiguousarray(signal.fftconvolve(numpySource, numpyPattern[::-1, ::-1], mode="valid"), 
                                dtype=np.float32)
    
    corr = normalize(corr)

    # Find the max value and print it
    ij = np.unravel_index(corr.argmax(), corr.shape)
    m_xs, m_ys = ij[::-1]

    isConfirmedMatch = not isFalsePositive(m_xs, m_ys, sourceArg, patternArg)

    if isConfirmedMatch:
        print "%s matches %s at %ix%i+%i+%i" % (patternName, sourceName, patternWidth, patternHeight, m_xs, m_ys)   
    
    return True

def isFalsePositive(xs, ys, sourceArg, patternArg):

    sourceName = sourceArg.rpartition('/')[2]
    sourceImage = Image.open(sourceArg)
    patternName = patternArg.rpartition('/')[2]
    patternImage = Image.open(patternArg)

    sourceImage = sourceImage.convert(mode="L")
    sourceWidth, sourceHeight = sourceImage.size
    patternImage = patternImage.convert(mode="L")
    patternWidth, patternHeight = patternImage.size
    patternMask = Image.new(mode="L", size=patternImage.size, color=1)

    score = patternWidth*patternHeight
    sourceCrop = sourceImage.crop((xs,ys,xs+patternWidth,ys+patternHeight))
    diff = ImageChops.difference(patternImage, sourceCrop)
    notequal = ImageChops.darker(diff,patternMask)
    countnotequal = sum(notequal.getdata())
    score -= countnotequal

    return score < (patternWidth * patternHeight * .03)    
        

def normalize(array, imin = -1, imax = 1):
    """
    I = Imin + (Imax-Imin)*(D-Dmin)/(Dmax-Dmin)

    """

    dmin = array.min()
    dmax = array.max()
    array -= dmin;
    array *= (imax - imin)
    array /= (dmax-dmin)
    array += imin

    return array

def printError(error, testerFlag):
    """
    Prints errors after appending 'Error: ' to the front of them.

    Arguments:
    error -- The error string to be printed
    testerFlag -- True if SPIMS is being run by the tester

    Errors are normally printed to standard error, but if SPIMS is 
    being run by the tester they are printed to standard out.

    """

    if testerFlag:
        print 'Error: ' + error
    else:
        print >> sys.stderr, 'Error: ' + error

def isValidType(filePath, testerFlag):
    """
    Determines whether or not the provided path is a valid image.

    Arguments:
    filePath -- The path to the file we are checking
    testerFlag -- True if SPIMS is being run by the tester

    Returns True if the file is a valid image, otherwise returns False.

    """

    # Make sure images exist and are of the correct type
    try:
        if isdir(filePath):
            printError('Received directory while expecting file!', testerFlag)
            return False

        validTypes = ['gif', 'jpeg', 'png']
        fileType = imghdr.what(filePath)

        if fileType not in validTypes:
            printError('Provided images must be GIF, JPEG, or PNG!', testerFlag)
            return False

    except IOError as e:
        printError('Image file cannot be found!', testerFlag)
        return False

    # Image is valid
    return True

def allValidTypes(patterns, sources, testerFlag):
    """
    Determines whether or not the provided files are valid types.

    Arguments:
    patterns -- The list of pattern paths
    sources -- The list of source paths
    testerFlag -- True if SPIMS is being run by the tester

    Returns True if all the files are valid, otherwise returns False.

    """

    # Make sure all patterns are valid
    for pattern in patterns:
        if not isValidType(pattern, testerFlag):
            return False

    # Make sure all sources are valid
    for source in sources:
        if not isValidType(source, testerFlag):
            return False

    # All are valid
    return True

def validateArgs(patternArg, patternDirArg, sourceArg, sourceDirArg, testerFlag):
    """
    Validates the arguments.

    Arguments:
    patternArg -- The path to the pattern image
    patternDirArg -- The path to the directory of pattern images
    sourceArg -- The path to the source image
    sourceDirArg -- The path to the directory of source images
    testerFlag -- True if SPIMS is being run by the tester

    Returns False if any arguments are invalid, otherwise 
    returns a tuple containing a list of patterns and a list of sources

    """

    # Make sure a pattern image is given
    if not patternArg and not patternDirArg:
        printError('Invalid Arguments. No pattern images provided!', testerFlag)
        return False
 
    # Make sure a source image is given
    if not sourceArg and not sourceDirArg:
        printError('Invalid Arguments. No source images provided!', testerFlag)
        return False

    # Make sure only one pattern arg is given
    if patternArg and patternDirArg:
        printError('Invalid Arguments. Must only provide one pattern argument!', testerFlag)
        return False

    # Make sure only one source arg is given
    if sourceArg and sourceDirArg:
        printError('Invalid Arguments. Must only provide one source argument!', testerFlag)
        return False

    # Creating lists of all patterns and sources
    patterns = []
    sources = []

    # Add the existing arguments to the lists
    if patternArg:
        patterns.append(patternArg)
    
    if sourceArg:
        sources.append(sourceArg)

    if patternDirArg:
        if not isdir(patternDirArg):
            printError('Given pattern directory is invalid!', testerFlag)
            return False

        for patternName in listdir(patternDirArg):
            patterns.append(join(patternDirArg, patternName))

    if sourceDirArg:
        if not isdir(sourceDirArg):
            printError('Given source directory is invalid!', testerFlag)
            return False

        for sourceName in listdir(sourceDirArg):
            sources.append(join(sourceDirArg, sourceName))

    # Make sure all paths are valid files
    if allValidTypes(patterns, sources, testerFlag):
        return patterns, sources

    return False

def main(argv):
    patternArg = None
    patternDirArg = None
    sourceArg = None
    sourceDirArg = None
    testerFlag = '-t' in argv
    
    if '-p' in argv:
        i = argv.index('-p') + 1
        if len(argv) > i:
            patternArg = argv[i]

    if '-pdir' in argv:
        i = argv.index('-pdir') + 1
        if len(argv) > i:
            patternDirArg = argv[i]

    if '-s' in argv:
        i = argv.index('-s') + 1
        if len(argv) > i:
            sourceArg = argv[i]

    if '-sdir' in argv:
        i = argv.index('-sdir') + 1
        if len(argv) > i:
            sourceDirArg = argv[i]

    # Validate the arguments and attempt to retrieve the pattern/source paths
    paths = validateArgs(patternArg, patternDirArg, sourceArg, sourceDirArg, testerFlag)

    if paths:
        # If path is not false, then it is a tuple of the patterns and sources
        patterns, sources = paths

        # Try to find matches between all combinations of patterns and sources
        for pattern in patterns:
            for source in sources:
                if not matchTemplate(pattern, source):
                    # Error occured while finding a match. Stop and exit.
                    return -1  
    else:
        # Arguments are invalid
        return -1 
   
    # Program completed successfully 
    return 1

if __name__ == "__main__":
    main(sys.argv[1:])
