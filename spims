#!/usr/bin/env python

import sys
import imghdr
import itertools
import cmath
import numpy as np
import multiprocessing as mp
from numpy.linalg import norm
from scipy import signal, ndimage
from PIL import Image, ImageChops
from os import listdir
from os.path import isdir, join

# Global Variables
SMALL_CONFIDENCE_INTERVAL = .95
LARGE_CONFIDENCE_INTERVAL = .03
ACCEPTABLE_OVERLAP = .5
MAX_MISSES = 100

def startMatching_star(p_s):
    startMatching(*p_s)


def startMatching(patternArg, sourceArg):
   
    patternName = patternArg.rpartition('/')[2]
    patternImg = Image.open(patternArg)
    
    patternWidth, patternHeight = patternImg.size

    sourceName = sourceArg.rpartition('/')[2]
    sourceImg = Image.open(sourceArg)

    if(patternWidth == 1 and patternHeight == 1 and False):
        matchOneByOne(patternImg, sourceImg, patternName, sourceName)
    else:
        patternImg = patternImg.convert('L')
        sourceImg = sourceImg.convert('L')
        matchTemplate(patternImg, sourceImg, patternName, sourceName)

#TODO
def matchOneByOne(patternImg, sourceImg, pName, sName):
    """
    Attempts to find the pattern image in the source image.
    
    Arguments:
    patternImg -- The loaded pattern image
    sourceImg -- The loaded source image 
    patternName -- The path to pattern Image
    sourceName -- The path to source image    

    """

    sourceWidth, sourceHeight = sourceImg.size
    patternWidth, patternHeight = patternImg.size

    patternMask = Image.new(mode="L", size=patternImg.size, color=1)
    
    for xs in range(sourceWidth+1):
        for ys in range(sourceHeight+1):
            sourceCrop = sourceImg.crop((xs,ys,xs+patternWidth,ys+patternHeight))
            diff = ImageChops.difference(patternImg, sourceCrop)
            notequal = ImageChops.darker(diff,patternMask)
            countnotequal = sum(notequal.getdata())
            
            if (countnotequal == 0):
                print "%s matches %s at %ix%i+%i+%i" % (patternName, sourceName, patternWidth, patternHeight, xs, ys)


def matchTemplate(patternImg, sourceImg, pName, sName, foundMatches=[], tryAgain=True):
    """
    Attempts to find the pattern image in the source image.

    Arguments:
    patternImg -- The loaded pattern image
    sourceImg -- The loaded source image 
    pName -- The path to pattern Image
    sName -- The path to source image

    Returns True if completed successfully AND match found

    """
    # Convert Source Image into a numpy array grayscaled
    numpySource = np.asarray(sourceImg)
    numpySource.flags.writeable = True
    numpySource = np.ascontiguousarray(numpySource, dtype=np.float32)

    # Convert Pattern Image into a numpy array grayscaled
    numpyPattern = np.asarray(patternImg)
    numpyPattern.flags.writeable = True
    numpyPattern = np.ascontiguousarray(numpyPattern, dtype=np.float32)

    # Get the original sizes of both images for normalization
    sourceWidth, sourceHeight = sourceImg.size
    patternWidth, patternHeight = patternImg.size

    if (patternWidth <= 10 and patternHeight <= 10 and sourceWidth <= 10 and sourceHeight <= 10):
        matchSmallTemplate(patternImg, sourceImg, pName, sName)
    else:
        # FFT using a Normalized Cross Correlation
        template_mean = np.mean(numpyPattern)
        numpyPattern -= template_mean
        corr = np.ascontiguousarray(signal.fftconvolve(numpySource, numpyPattern[::-1, ::-1], mode="valid"), 
                                    dtype=np.float32)

        misses = 0

        while (misses <  MAX_MISSES):
            ij = np.unravel_index(corr.argmax(), corr.shape)
            m_xs, m_ys = ij[::-1]
            overlapping = isOverlappingMatch(foundMatches,m_xs, m_ys, patternWidth, patternHeight)

            if not overlapping and isConfirmedMatch(m_xs, m_ys, sourceImg, patternImg):
                foundMatches.append(([m_xs, m_ys], patternWidth, patternHeight))
                print "%s matches %s at %ix%i+%i+%i" % (pName, sName, patternWidth, patternHeight, m_xs, m_ys)
            
            if not overlapping:
                misses = misses + 1
            
            corr[ij] = 0

def isConfirmedMatch(xs, ys, sourceImage, patternImage):
    sourceWidth, sourceHeight = sourceImage.size
    patternWidth, patternHeight = patternImage.size
    patternMask = Image.new(mode="L", size=patternImage.size, color=1)

    if (xs > sourceWidth or ys > sourceHeight):
	return False
    
    score = patternWidth*patternHeight
    sourceCrop = sourceImage.crop((xs,ys,xs+patternWidth,ys+patternHeight))
    diff = ImageChops.difference(patternImage, sourceCrop)
    notequal = ImageChops.darker(diff,patternMask)
    countnotequal = sum(notequal.getdata())
    score -= countnotequal
    return score >= (patternWidth * patternHeight * LARGE_CONFIDENCE_INTERVAL)
     
def matchSmallTemplate(patternImage, sourceImage, pName, sName):
    """
    Attempts to find the pattern image in the source image.
    
    Arguments:
    patternImg -- The loaded pattern image
    sourceImg -- The loaded source image 
    pName -- The path to pattern Image
    sName -- The path to source image    

    """

    foundMatches = []

    sourceWidth, sourceHeight = sourceImage.size
    patternWidth, patternHeight = patternImage.size
    patternMask = Image.new(mode="L", size=patternImage.size, color=1)
    
    for xs in range(sourceWidth-patternWidth+1):
        for ys in range(sourceHeight-patternHeight+1):
            score = patternWidth*patternHeight
            sourceCrop = sourceImage.crop((xs,ys,xs+patternWidth,ys+patternHeight))
            diff = ImageChops.difference(patternImage, sourceCrop)
            notequal = ImageChops.darker(diff,patternMask)
            countnotequal = sum(notequal.getdata())
            score -= countnotequal

            inConfidenceRange = score >= (patternWidth * patternHeight * SMALL_CONFIDENCE_INTERVAL)

            if inConfidenceRange and not isOverlappingMatch(foundMatches, xs, ys, patternWidth, patternHeight):    
                foundMatches.append(([xs, ys], patternWidth, patternHeight))
                print "%s matches %s at %ix%i+%i+%i" % (pName, sName, patternWidth, patternHeight, xs, ys)

def isOverlappingMatch (matches, x, y, width, height):
    for match in matches:
        x11 = match[0][0]
        y11 = match[0][1]
        x12 = match[0][0] + match[1]
        y12 = match[0][1] + match[2]
        
        x21 = x
        y21 = y
        x22 = x + width
        y22 = y + height
        
        x_overlap = max(0, min(x12, x22) - max(x11, x21))
        y_overlap = max(0, min(y12, y22) - max(y11, y21))
    
        if ((x_overlap * y_overlap) >= ((width * height) * ACCEPTABLE_OVERLAP)):
            return True
    return False

def printError(error):
    """
    Prints errors after appending 'Error: ' to the front of them.

    Arguments:
    error -- The error string to be printed

    Errors are normally printed to standard error, but if SPIMS is 
    being run by the tester they are printed to standard out.

    """

    print >> sys.stderr, 'Error: ' + error

def isValidType(filePath):
    """
    Determines whether or not the provided path is a valid image.

    Arguments:
    filePath -- The path to the file we are checking

    Returns True if the file is a valid image, otherwise returns False.

    """

    # Make sure images exist and are of the correct type
    try:
        if isdir(filePath):
            printError('Received directory while expecting file!')
            return False

        validTypes = ['gif', 'jpeg', 'png']
        fileType = imghdr.what(filePath)

        if fileType not in validTypes:
            printError('Provided images must be GIF, JPEG, or PNG!')
            return False

    except IOError as e:
        printError('Image file cannot be found!')
        return False

    # Image is valid
    return True

def allValidTypes(patterns, sources):
    """
    Determines whether or not the provided files are valid types.

    Arguments:
    patterns -- The list of pattern paths
    sources -- The list of source paths

    Returns True if all the files are valid, otherwise returns False.

    """

    # Make sure all patterns are valid
    for pattern in patterns:
        if not isValidType(pattern):
            return False

    # Make sure all sources are valid
    for source in sources:
        if not isValidType(source):
            return False

    # All are valid
    return True

def validateArgs(patternArg, patternDirArg, sourceArg, sourceDirArg):
    """
    Validates the arguments.

    Arguments:
    patternArg -- The path to the pattern image
    patternDirArg -- The path to the directory of pattern images
    sourceArg -- The path to the source image
    sourceDirArg -- The path to the directory of source images

    Returns False if any arguments are invalid, otherwise 
    returns a tuple containing a list of patterns and a list of sources

    """

    # Make sure a pattern image is given
    if not patternArg and not patternDirArg:
        printError('Invalid Arguments. No pattern images provided!')
        return False
 
    # Make sure a source image is given
    if not sourceArg and not sourceDirArg:
        printError('Invalid Arguments. No source images provided!')
        return False

    # Make sure only one pattern arg is given
    if patternArg and patternDirArg:
        printError('Invalid Arguments. Must only provide one pattern argument!')
        return False

    # Make sure only one source arg is given
    if sourceArg and sourceDirArg:
        printError('Invalid Arguments. Must only provide one source argument!')
        return False

    # Creating lists of all patterns and sources
    patterns = []
    sources = []

    # Add the existing arguments to the lists
    if patternArg:
        patterns.append(patternArg)
    
    if sourceArg:
        sources.append(sourceArg)

    if patternDirArg:
        if not isdir(patternDirArg):
            printError('Given pattern directory is invalid!')
            return False

        for patternName in listdir(patternDirArg):
            patterns.append(join(patternDirArg, patternName))

    if sourceDirArg:
        if not isdir(sourceDirArg):
            printError('Given source directory is invalid!')
            return False

        for sourceName in listdir(sourceDirArg):
            sources.append(join(sourceDirArg, sourceName))

    # Make sure all paths are valid files
    if allValidTypes(patterns, sources):
        return patterns, sources

    return False

def main(argv):
    patternArg = None
    patternDirArg = None
    sourceArg = None
    sourceDirArg = None
    
    if '-p' in argv:
        i = argv.index('-p') + 1
        if len(argv) > i:
            patternArg = argv[i]

    if '-pdir' in argv:
        i = argv.index('-pdir') + 1
        if len(argv) > i:
            patternDirArg = argv[i]

    if '--pdir' in argv:
        i = argv.index('--pdir') + 1
        if len(argv) > i:
            patternDirArg = argv[i]

    if '-s' in argv:
        i = argv.index('-s') + 1
        if len(argv) > i:
            sourceArg = argv[i]

    if '-sdir' in argv:
        i = argv.index('-sdir') + 1
        if len(argv) > i:
            sourceDirArg = argv[i]

    if '--sdir' in argv:
        i = argv.index('--sdir') + 1
        if len(argv) > i:
            sourceDirArg = argv[i]

    argc = len(argv)
    # Handle inputs that aren't standard
    if argc != 4:
        printError("Invalid number of arguments")
        return -1

    # Validate the arguments and attempt to retrieve the pattern/source paths
    paths = validateArgs(patternArg, patternDirArg, sourceArg, sourceDirArg)

    if paths:
        # If path is not false, then it is a tuple of the patterns and sources
        patterns, sources = paths

        try:
            pool = mp.Pool(processes=mp.cpu_count())
            pool.map(startMatching_star, itertools.product(patterns, sources))
        except Exception, errtxt:
            # Error occured while finding a match. Stop and exit.
            print errtxt
            return -1
    else:
        # Arguments are invalid
        return -1 
   
    # Program completed successfully 
    return 1

if __name__ == "__main__":
    main(sys.argv[1:])
